## Part 1: Installing
1. Making a project- choose a dir then type "django-admin startproject
{project name.let's use (mysite)}"

2. Making an app- python3 manage.py startapp {name. lets use (main)}.

adittional: (Making a simple message 'hello world')
1. Go to polls/views.py and type:
from django.http import HttpResponse

def func1(request):
    return HttpResponse('hello world')

2. Make a file urls.py at main and type:
from django.urls import path
from . import views

urlpatterns = [
    path('helloworld/',views.func1)
]

3. In mysite/urls.py, follow the ff. for URLConf/URL Configuration

## Part 2: Database setting up, creating first model, and a quick intro to
Django’s automatically-generated admin site
1. Database Setup
- Head to the mysite/settings.py and as you notice it is full of module-level
stuffs. 

1.1. Database dictionary- Django has installed database already which is SQLite.
But you can change your db if you want, other db like mySQL, oracle, etc.
As if you notice the DATABASE dict, it contains 2 items:
* ENGINE (depends what backend and db you are using)
* NAME (contains full path (including filename). The default val contains 
BASE_DIR / 'db.sqlite3' will store that file in project dir)

1.2. Set the TIME_ZONE on your timezone

1.3. INSTALLED_APPS- it has all the app names. It has default apps which is
listed because of the common cases. List your apps in here by typing the dir
of apps upto class inside the apps.py.
Format: {app nm}.apps.{app nm}Config - class from apps.py
EX: main.apps.MainsConfig

1.4. Migrating- to migrate, type 'python3 manage.py migrate'. It creates a 
necessary db tables based on apps present at INSTALLED_APPS and writes
them in your backend/db.

2. Creating Models
Model.py- contains fields(models) and characteristics of your data stored

2.1. Fields(models/classes)- represented  by every instance inside.
- in our example like the ToDoList field/model, we have instances;
*name = contains models.CharField(maxlength=200), is for character fields

- On Items field, we have a ForeignKey() which is to identify relationship
between two fields/classes. Thats why it contains Question class as its
parameter. Its 2nd parameter is 'on_delete = models.CASCADE' means if we 
delete item/s ToDoList, we also delete its data in Items

- We also add __str__() inside each models that returns something they
contain.

3. Activating Models
3.1. Django apps can be use in different django projects just make sure they
are listed on INSTALLED_APPS at inner django project folder/settings.py.

- Run the code; "python3 manage.py makemigrations main" to declare
to django that you make some changes on your models (also your database
schema) and you want to save the changes on disk(through migration).

3.2. main/migrations/0001_initial.py saves the migrations that happened.
They are editable, incase you want to modify something

3.3. command "python3 manage.py sqlmigration main 0001": takes migration
names and returns their SQL

Note the following:
- The exact output will vary depending on the database you are using. The
example above is generated for PostgreSQL.
- Table names are automatically generated by combining the name of the app
(polls) and the lowercase name of the model – question and choice. (You can
override this behavior.)

- Primary keys (IDs) are added automatically. (You can override this, too.)

- By convention, Django appends "_id" to the foreign key field name. (Yes,
you can override this, as well.)

- The foreign key relationship is made explicit by a FOREIGN KEY constraint.
Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not
enforce the foreign key until the end of the transaction.

- It’s tailored to the database you’re using, so database-specific field
types such as auto_increment (MySQL), serial (PostgreSQL), or integer
primary key autoincrement (SQLite) are handled for you automatically. Same
goes for the quoting of field names – e.g., using double quotes or single
quotes.

- The sqlmigrate command doesn’t actually run the migration on your db
instead,
it prints it to the screen so that you can see what SQL Django
thinks is required. It’s useful for checking what Django is going to do or
if you have database administrators who require SQL scripts for changes.

3.4. python manage.py check; this checks for any problems in your project
without making migrations or touching the database.


3.5. 3 steps in making model changes
- Change your models (in models.py).
- 'python manage.py makemigrations' to create migrations for those changes
- 'python manage.py migrate' to apply those changes to the database.

* Migrations are very powerful and let you change your models over time, as you develop your project, without the need to delete your database or tables
and make new ones - it specializes in upgrading your database live, without
losing data.

4. Writing and Saving in Database
4.1. Open iPython for manage.py via: python3 manage.py shell.

4.2. Import your models: from main.models import ToDoList,Items.

4.3. Adding data in database is just easy. Lets try adding some data: 
t = ToDoList(name="Michael's Studies"). To save it, simply add: t.save().

4.4. ToDoList.objects.all(): To see all your object, run.

4.5. ToDoList.objects.get(id={object id}): To get a specific data using id.

4.6. ToDoList.objects.get(name='{word}'): to search via name.

4.7. To show its items from relative class:
format: t.{relative class name}_set.all()
ex: t.items_set.all()

4.8. To add items in todolist at t, you must use t.items_set.create(follow the patterns(give 
what the instances onto they need)).
Ex: t.items_set.create(text='Finish django',complete=False)

4.9. If you already exit the iPython and you want to access the db inside it,
just import what we import before again to access this db.

*Working to show this datas in a webpage

1. Lets edit the urlpatterns at main/urls.py to looks like this:
	urlpatterns = [path("<int:id>", views.index, name = "index")]

2. Then at the views.py: from .models import todolist,items

3. The "<int:id>" means it needs an int which is an id for an items/todolist.

4. Lets also modify index()
	def index(response, id):
		ls  = todolist.objects.get(id = id)
		itm = ls.items_set.get(id = 1)
		return HttpResponse('<h1>%s</h1></br><p>%s</p>' % ls.name,itm.text)

ADDITIONAL; If you want to search something in your db, try:
todolist.objects.filter(name__startwith='{str}')

5. Admin dashboard
5.1. Run 'python3 manage.py createsuperuser' then sign up there

5.2. Next, go to your admin page through {link}/admin/ and log in there.
You can see there all the objects registered.

5.3. To register a model and its data;
	-Go to admin.py at app folder then, import a model
		-Ex: from .models import todolist
	-To register: admin.site.register({model})
		-Ex: admin.site.register(todolist)

6. Customizing Templates
6.1. Create a templates dir inside the main dir, then inside templates create
main dir. Should looks like this: mysite/main/templates/main/

6.2. Create a 2 different pages; base.html and home.html
	- make a page at base.html then import it in home.html

	- WHY SEPARATE?! Because it is for all of the users. It gives a user
	a starting/home page independently so you dont need to code it all for
	your users individually.
	-base.html example texts:
			<!DOCTYPE html>
			<html>
			<head>
				<title>Todo Fucking List</title>
			</head>
			<body>
				<h1>Title</h1>
				<p>paragraph</p>
			</body>
			</html>

6.3. Showing objects in Browser
-Add this in main/urls.py/urlpatterns: path("", views.home, name = "home")

-Remove the </p> and change the </h1> to => <h1>{{name}}</h1>. Remember,
{{name}} is a variable

-Write this code in your main/views.py:
	def index(response,id):
		cnt = todolist.objects.get(id = id)
		return render(response,'main/base.html',{'name':cnt.name})

	def home(response):
		return render(response,'main/home.html',{'name':'test'})
--this means if you had id in link, it returns the list.name, else returns
  the word test
6.4. Showing objects with its item in Browser
6.4.1. Modify the base.html:
	<!DOCTYPE html>
	<html>
	<head>
		<!-- using blocks:allows us to insert/modify all of inside of it when
		modifying it from other file just make sure put blocks & insert thing
		on its middle -->
		<title>{% block title %}Todo Fucking List{% endblock %}</title>
	</head>
	<body>
		<div id='content',name='content'>
			{% block content %}
			{% endblock %}
		</div>

	</body>
	</html>

-{blocks} - to modify that part in some cases


6.4.2. Modify the views.py:
	from .models import todolist,items

	def index(response,id):
		cnt = todolist.objects.get(id = id)
		return render(response,'main/list.html',{'cnt':cnt})

	def home(response):
		return render(response,'main/home.html',{})

-@ index(), we get the id as an input. We access what that id contains and we
return its value


6.4.3. Create and modify the list.html
	<!-- Import -->
	{% extends 'main/base.html' %}

	{% block content %}
	<!-- It get the name of the object that we get from the index() in no.2 -->
	<h1>{{cnt.name}}</h1>

	<!-- making lists, <li> for list items -->
	<ul>
		<!-- a python code were it get all the items inside that object -->
		{% for items in cnt.items_set.all %}
			<!--asks if the task is complete or not - get the complete instance-->
			{% if items.complete == True %}
				<!-- return all the items using this -->			
				<li>{{items.text}} - COMPLETE</li>
			{% else %}
				<li>{{items.text}} - INCOMPLETE</li>
			{% endif %} <!-- ends if statement here -->
		{% endfor %} <!-- ends the loop here -->
	</ul>

	{% endblock %}

